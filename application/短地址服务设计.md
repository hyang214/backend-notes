# 短地址服务设计

## 问题

### 产生原因
为了解决url过长，不方便信息传递的问题，将一个较长的地址转换成一个较短的。
最早的短地址由Kevin Gilbertson在2002年创建。

### 问题描述
将一个 较长的 url 转换成一个固定长度的短地址。主要用于有字数限制的场景，比如：twitter或者微博(140字)，给用户发的短信等等。

考虑如下问题：
+ 现实中的url不受限于长度，理论上市无穷无尽
+ 受限于设计要求，短地址长度长度有限，有大小写+数字=62个字符，6位长度562亿，8位长度2^14
+ （无穷无尽的长地址）+ （空间是有限的短地址) ->无法设计出满足**双射**的函数来实现转换
	+ 一个完美的Hash函数，实现一一对应，就是不可能的
+ 无法双射 -> 必然出现碰撞
+ 出现碰撞 -> 解码逻辑需要依靠存储的 （长，短）地址映射数据库 空间成本
+ 依靠存储 -> 解码需要查询 -> 查询性能要求

## 解决方案

### 无hash方案
如[2]中的方案
不试图通过hash的方式，来生成短地址，而是通过给请求赋予一个数值，然后将这个base 10的值转成一个6位的base 62的字符串。
从0开始增长，没来一个请求，序号就+1，将序号通过base 62转换为字符串，字符串就是短地址。

问题
1. 生成的url是连续
	+ 上一个是n，下一个就是n+1，因此base62转码后，2个相邻的url的前缀也是相同的
2. 分布式的情况下，强依赖于发号器
3. 相同的url，无法生成相同的短地址
4. 空间耗尽后，重用的情况下，地址必须被覆盖
	+ 否则发号器，需要跳过还在使用的地址，十分复杂


改进：
对于问题1：
可以考虑用一个算法，修改发号器遍历整个空间的顺序，不再由末位+1的方式来实现，而是通过不定的位的翻转来实现
这样的话，连续的号在数值上是不连续的，对应而言，在生成的字符串上，也就不是连续的了。

对于问题2：
无法解决，可以考虑高可用的发号器系统来保证。

对于问题3：
显然无法彻底解决，因为考虑性能，不可能每次都查询数据库，可以通过缓存来部分解决
+ 对于生成的短地址，缓存(长地址，短地址)一段时间，这段时间内，重复生成地址都是相同的
+ 从而解决空间，且更友好
+ 缓存空间，可以考虑LRU或者其他替换策略，控制空间大小

对于问题4：
无法解决，只能第二轮全部覆盖






## Reference
1. [[转]微博URL短网址生成算法原理及（java版、php版实现实例](https://www.cnblogs.com/latteyan/articles/5845117.html)
2. [URL-Shortening Service in Java, Spring Boot and Redis](https://hackernoon.com/url-shortening-service-in-java-spring-boot-and-redis-d2a0f8848a1d)
3. [短 URL 系统是怎么设计的](https://www.zhihu.com/question/29270034)
4. [短链接服务架构设计与实现](https://blog.csdn.net/lz0426001/article/details/52370177)
[短网址服务系统如何设计](https://www.jianshu.com/p/d1cb7a51e7e5)