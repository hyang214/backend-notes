# 排序算法

[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)

### 冒泡排序
依次比较相邻的2个元素，然后进行交换
~~~
int[] array = [.....];
for (var i = 0; i < array.length - 1 ; i ++) {
    for (var j = 0; j = array.length - 1 - i ; j ++) {
        if (array[i] > array[j]) {
            var tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
        }
    }
}
~~~

### 选择排序
对于第i个位置，从剩下的len-i中选择最小的元素，与第i个元素进行交换
可以看错是冒泡的改进

+ 相比与冒泡，比较次数没有减少，只是减少了交换次数
~~~
int[] array = [.....];
for (var i = 0; i < array.length - 1 ; i ++) {
     int swapIndex = i;
​    for (var j = 0; j = array.length; j ++) {
​        if (array[j] < array[swapIndex]) {
​            swapIndex = j;
​        }
​    }
	int tmp = array[i];
	array[i] = array[swapIndex];
	array[swapIndex] = tmp;
}
~~~

### 快速排序
+ 选择排序的改进
+ 对于一个基准，然后用这个基准
	+ 从后向前，与比这个元素小的交换
	+ 从前向后，与被这个元素大的交换
	+ 一趟之后，保证该元素在整个序列中的位置定下来
	+ 并且是的整个序列更加有序

### 插入排序
相比于选择，最好时间复杂度更优，为O(n)

对于i，之前的已经局部有序了，现在将i从后往前(从i-1到0)，依次比较，如果array[i]更小，就继续向前寻找，直到出现一个j使得array[j] < array[i]，这个时候，把元素i插入到这个位置之后，后面的元素全部向后移动一位；

与选择排序的最大差异在于
+ 选择比较的时候
	+ 选择排序的是将当前元素与剩下的未排序的选择
	+ 插入排序是将当前元素与已经排序的进行比较，且只要找到一个满足的，就会停止(单调性)

~~~
int[] array = [.....];
for (var i = 0; i < array.length - 1 ; i ++) {
	preIndex = i - 1;
    current = arr[i];
    while (preIndex >= 0 && array[preIndex] > current) {
    	array[preIndex + 1] = array[preIndex];
        preIndex--;
    }
    array[preIndex + 1] = current;
}
~~~

### Shell Sort
先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量  =1(  <  …<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。
+ 是对于插入排序的改进，分组进行插入排序

### 归并排序
+ 把长度为n的输入序列分成两个长度为n/2的子序列；
+ 对这两个子序列分别采用归并排序；
	+ 当子序列长度为1的时候，直接返回；
+ 将两个排序好的子序列合并成一个最终的排序序列。
	+ 开辟新的空间来存储排序后的结果
+ 与Shell Sort相比，Shell Sort是每次比较较远的元素，而归并排序每次都是比较最近的元素

### 堆排序
主要利用大顶堆的性质
在堆里面调整，将最大元素找出来，性能很好
+ 全部元素构造一个大顶堆，把堆顶元素拿出来，作为输出的一个元素
+ 将堆的最后一个元素，放入原来堆顶的位置
+ 重新调整堆，是的剩下元素中的最大值，重新出现在堆顶，然后拿走
+ 重复以上步骤，直到堆未空

### 计数排序
+ 找出序列中最大值和最小值，开辟Max-Min+1的辅助空间
+ 最小的数对应下标为0的位置，遇到一个数就给对应下标处的值+1,。
+ 遍历一遍辅助空间，就可以得到有序的一组序列

### 桶排序
桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。
+ 计数排序，可以当做hash函数是 % 1的桶排序

### 基数排序
从低位到高位：
+ 每一位进行一趟，进行收集然后输出，保证这一位的顺序是从小到大的

### 比较排序的下线
O(nlogn)









