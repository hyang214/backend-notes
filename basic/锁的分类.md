# 锁的分类

## 1 锁的分类
+ 公平锁/非公平锁
+ 可重入锁
+ 独享锁/共享锁
+ 互斥锁/读写锁
+ 乐观锁/悲观锁
+ 分段锁
+ 自旋锁
+ 联锁(MultiLock)
+ 红锁(RedLock)

## 2 分类描述

### 2.1 公平锁/非公平锁

所谓公平和非公平，是指申请锁的线程获取锁的顺序。
+ 公平锁：多个线程按照申请锁的顺序来获取锁
+ 非公平锁：多个线程获取锁的和申请的顺序无关，可能会造成饥饿现象

### 2.2 可重入锁

所谓可重入，是指相同的进程在申请到锁后，再次申请锁的时候，依旧可以获取。
可重入锁一般会需要一个计数器来记录重入的次数，在释放锁的时候，如果计数大于1，都只是减计数，只有当剩余计数为1的时候，才真正释放锁。

### 2.3 独享锁/共享锁

所谓独享和共享，是指资源的锁是否可以被多个进程同时持有。
+ 独享锁：多个线程申请锁，同一时间，只有一个线程可以持有锁
+ 共享锁：多个线程申请锁，同一时间，多个线程可以同时持有锁

### 2.4 互斥锁/读写锁

和[2.3 独享锁/共享锁](#2.3 独享锁/共享锁)的分类比较类似。
所谓互斥和读写，是从锁的功能层面来定义的。
+ 互斥锁：和独享锁是一致的，多个线程申请锁，同一时间，只有一个线程可以持有锁
+ 读写锁：独享锁和共享锁的结合
    + 构成：读锁和写锁
    + 共享
        + 不同线程之间的读锁和读锁共享
        + 相同线程的读锁和写锁共享
    + 互斥
        + 不同线程之间的读锁和写锁互斥
        + 不同线程之间的写锁和写锁互斥

### 2.5 乐观锁/悲观锁

所谓乐观和悲观，是指在并发同步的角度上，是加锁，还是通过尝试更新的方式来控制临界资源。
+ 乐观锁：认为对于资源的访问，大概率<b>不</b>会出现并发冲突，所以只有在执行更新的时候，通过版本号作为更新条件，来控制并发修改。类似于CAS的思想。
+ 悲观锁：认为对于资源的访问，大概率会出现并发冲突，所以在访问前，先进行加锁，然后执行，最后释放。

### 2.6 分段锁

所谓分段锁，并不是单独的一种锁类型，而是对于锁的粒度的优化。
本质还是：独享锁、互斥锁、悲观锁。
将原本对于整个对象的锁，转换为对对象内部某个分段的锁。

### 2.7 自旋锁

所谓自旋，是指加锁的重试策略，自旋会循环去尝试获取锁
+ 减少线程上下文切换的消耗
+ 循环会消耗CPU

### 2.8 MultiLock

所谓MultiLock，是指将多个独立的可加锁对象，组合成一个大锁，然后进行统一的申请加锁以及释放锁。

### 2.9 RedLock

所谓RedLock，并不是锁的一种，而是分布式锁HA的一种使用方式。
对于独立的多个（奇数2N+1）分布式锁服务，同时对全部分布式锁服务请求加锁。如果有至少N+1个服务返回加锁成功，那么就正在获得了锁。否则就释放全部锁。

## Java锁的分类

### Synchronized
分类：
+ 非公平锁
+ 可重入锁
+ 独享锁
+ 互斥锁
+ 悲观锁

### ReadWriteLock
分类：
+ 非公平锁
+ 可重入锁
+ 独享锁/共享锁
	+ 读锁：共享锁
	+ 写锁：独享锁
+ 读写锁
+ 悲观锁

### ReentrantLock
分类：
+ 公平锁/非公平锁
	+ 同时支持2种类型，通过构造函数指定该锁是否是公平锁
	+ 默认是非公平锁
+ 可重入锁
+ 独享锁
+ 互斥锁
+ 悲观锁

### CAS 和 原子类
+ 乐观锁
+ 自选锁

### ConcurrentHashMap
+ 分段锁

## Reference
1. [Java中的锁分类](https://www.cnblogs.com/qifengshi/p/6831055.html)
2. [分布式Redis的分布式锁 Redlock](https://www.cnblogs.com/sheldon-lou/p/11039795.html)
3. [redisson的MultiLock连锁](https://cloud.tencent.com/developer/article/1386478)










