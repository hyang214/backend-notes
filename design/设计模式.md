# 设计模式

## 创建模式
克隆模式、工厂模式、单例模式、Builder模式

### 克隆模式(原型模式)
通过java的clone方法来创建对象实例，然后再修改信息；

### 单例模式
对象只创一个对象，可以通过对此检查来实现，或者enum
+ 饿汉式模式：static定义并创建，获取的时候不需要判断，空间换时间
+ 懒汉模式：获取的时候进行判断，如果没有就创建，然后返回

### 工模式
#### 简单工厂模式(静态工厂模式)
一个工厂类，通过static方法，输入typeName之类的参数，创建对应的对象，并且返回；

#### 方法工厂
业务方通过代码注入相应的工厂具体实现，就能实现代码不变的情况下，替换具体的方法了

 *  Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
 *  ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
 *  Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
 *  ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

#### 抽象工厂
抽象工厂是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。系统的产品多于一个产品族，而系统只消费某一族的产品。当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
+ 与方法工厂相比，有多个方法

 * AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
 * ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
 * AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
 * ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

### 池化模式
对象的创建后，进行池化
+ 使用和释放都通过池化进行
+ 减少初始化的消耗

### 建造者模式
类似与模板模式，抽象的Builder定义创建类需要的各个方法；
Builder的实现类，负责实现对应的方法；
Director负责调用和组装，然后返回创建好的对象；


## 结构模式
适配器模式，桥接模式，组合模式，装饰模式，外观模式，享元模式，代理模式

### 适配器模式
对用户暴露一个接口，但是底层是通过调用另外的接口实现的

#### 对象适配
通过传入对象来实现适配

#### 接口适配
对于大量需要实现的接口，提供一些默认实现，减少代码冗余

#### 类适配
通过继承底层实现类，再在其实实现适配

### 桥接模式
对于n\*m的可能性，不分别是这么多个类
而是分别是n个 + m个，然后通过桥接，联系在一起
本质就是传入其中一个的对象，然后使用

### 组合模式
内部为树形结构，任意部分，对外暴露都是一致的
+ Component 抽象构件：接口或抽象类，为叶子构件和容器构件的声明接口，包含了2者的全部公共方法和各种的私有方法
+ Leaf 叶子构件：在组合结构中，表示叶子对象，没有子节点，负责实际的业务处理，不实现管理节点的方法
+ Composite 容器构件：在组合容器结构中，表示容器对象，其子节点，可以是容器或者叶子，包含管理叶子节点的方法，且业务处理，

本质为递归调用其子节点的业务处理

### 装饰模式
+ Component 抽象构件：具体构件和抽象装饰类的共同父类，声明了具体的业务方法，使得客户端一致的访问装饰前和装饰后的对象
+ Concrete Component 具体构件：抽象构件的子类，具体的核心业务方法的实现类，通过装饰类增加职责
+ Decorator 抽象装饰器：抽象构件的子类，用于给具体构件增加职责，本身不实现核心的功能，只是增加额外的职责，具体逻辑再子类中；
+ Concrete Decorator 具体装饰器：抽象装饰器的子类，实现增加职责；

### 外观模式
Facade 外观角色：对外封装内部子系统的各种细节，将外部系统的请求，分发到各个子系统
Sub System 子系统角色：可以被客户端和外观角色调用，子系统无感知

客户端 -> 
​	+ 外观角色 
​		+ -> 子系统A  
​		+ -> 子系统B
​		+ -> 子系统C

### 享元模式
底层的元素全是不可变的对象，上层的对象内部使用不可变对象的引用。

### 代理模式
基于子类的
基于接口的

## 行为模式
责任链模式、命令模式、解释器模式、迭代器模式、中介模式、备忘录模式、观察者模式、状态模式 和 策略模式，访问者模式

### 责任链
对应责任链的组织
 *      1. 使用后继，每个handler自己维持自己的后继
 *      2. 使用一个总的Chain的维护，然后chain中保存全部的handler，每次handler处理完成，让chain来决定下一个handler

### 命令模式
类似于策略模式，不过调用方进行了封装，叫做invoker

### 解释器模式
解析语法树，然后依次执行每个节点自己的规则

### 迭代器模式
封装了对应容器的访问

### 中介者模式
通过一个对象，来通知其他对象，而不是直接调用

### 备忘录模式
通过一个备忘录，来存储对象原信息，以实现恢复

### 观察者模式
负责一个目标 与 多个观察者之间的通讯
与中介模式不同，是对象直接通知观察者，而不是通过中介去实现

### 状态模式
每个状态都实现，全部的方法，然后根据当前的状态和信息，调用对应状态的对应方法，执行该状态下的对应行为

### 策略模式
传入不同的策略，执行相同的方法

### 模板模式
在模板中指定执行的流程
子类实现具体的方法

### 访问者模式
对每个元素执行某种操作







