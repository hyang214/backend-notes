# 分布式事务

## 1. 事务分类

### 柔性事务
#### 定义
满足BASE原则
​	+ 基本可用 **B**asic **A**vaiable
​	+ 软状态 **S**oft State
​	+ 最终一致 **E**ventual Consistency

### 分类
+ 两阶段型
+ 补偿型
+ 异步确保型
+ 最大努力通知

### 刚性事务(传统事务)
#### 定义
+ 满足ACID原则
	+ 原子性
	+ 一致性
	+ 隔离性
	+ 持久性

## 2. 事务实现

### 2PC
两端提交方式

#### 构成
+ 事务协调者：协调资源管理器的事务提交和回滚
+ 资源管理器：各个参与事务的独立资源管理单元

#### 流程
**Phase 1: Prepare**
+ 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。
	+ 各参与者执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）
		+ 如参与者执行成功，给协调者反馈YES，即可以提交；
		+ 如执行失败，给协调者反馈NO，即不可提交。

**Phase 2: Commit**
+ 协调者根据参与者的返回，决定提交或者放弃
	+ 所有参与者均反馈YES时，即提交事务，协调者发送commit请求。
		+ 参与者执行Commit请求，并释放整个事务期间占用的资源。
		+ 向协调者反馈Ack完成的消息。
	+ 任何一个参与者反馈NO时，即中断事务，协调者发送abort请求。
		+ 参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。
		+ 各参与者向协调者反馈Ack完成的消息。

#### 缺陷
+ 同步阻塞：最大的问题即同步阻塞，即：所有参与事务的逻辑均处于阻塞状态。
+ 单点：协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态。
	+ 是否可以通过超时时间来控制？
+ 脑裂：在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。	
	+ 提交阶段，出现网络未响应无法知道是否成功提交

### 3PC
#### 与2PC相比
三段提交，相比与二段提交
+ 引入超时机制。同时在协调者和参与者中都引入超时机制。并且在超时的情况下，参与者会按照规则进行处理，保证不长期阻塞
+ 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
+ 脑裂问题依旧未完全解决

#### 解决了2PC的问题
+ 参与者在协调者没有反馈的情况下，也会按规则进行处理，从而解决了如下问题
	+ 单点故障问题：协调者允许挂掉，事务可以继续
	+ 降低阻塞：一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态

+ 超时的处理逻辑
	+ 阶段1: 协调者或协调者备份未收到宕机参与者的vote，直接中止事务；宕机的参与者恢复后，读取logging发现未发出赞成vote，自行中止该次事务
	+ 阶段2: 协调者未收到宕机参与者的precommit ACK，但因为之前已经收到了宕机参与者的赞成反馈(不然也不会进入到阶段2)，协调者进行commit；协调者备份可以通过问询其他参与者获得这些信息，过程同理；宕机的参与者恢复后发现收到precommit或已经发出赞成vote，则自行commit该次事务
	+ 阶段3: 即便协调者或协调者备份未收到宕机参与者t的commit ACK，也结束该次事务；宕机的参与者恢复后发现收到commit或者precommit，也将自行commit该次事务

#### 构成
构成，和二段提交是一致的
+ 事务协调者：协调资源管理器的事务提交和回滚
+ 资源管理器：各个参与事务的独立资源管理单元

#### 流程
**Phase 1: canCommit**
+ 协调者向所有参与者发出包含事务内容的canCommit请求，询问是否可以提交事务，并等待所有参与者答复。
	+ 参与者收到canCommit请求后
		+ 如果认为可以执行事务操作，则反馈YES并进入预备状态
		+ 否则反馈NO

**Phase 2: preCommit**
+ 协调者根据参与者的返回，决定执行
+ 至少一个未返回YES(包括超时无响应)，放弃执行
	+ 协调者向所有参与者发出abort请求。
	+ 无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。
+ 全部返回YES，协调者向所有参与者发出包含事务内容的preCommit请求，要求执行事务，但是不提交，并等待所有参与者答复。
	+ 参与者收到preCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）
		+ 执行成功，返回YES
		+ 执行失败，返回NO

**Phase 3: doCommit**
+ 协调者根据参与者的返回，决定执行
+ 至少一个未返回YES(包括超时无响应)，中断事务，协调者向所有参与者发出abort请求。
	+ 参与者收到abort请求后
    ​    + 事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
    ​    + 反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息
	+ 如果参与者超时未收到abort请求，默认会当做doCommit处理
+ 全部返回YES，协调者从预提交状态进入到提交状态。并向所有参与者发送doCommit请求
	+ 参与者收到doCommit请求后
		+ 执行正式的事务提交。并在完成事务提交之后释放所有事务资源
		+ 事务提交完之后，向协调者发送Ack响应
+ 协调者最后进行事务提交和中断

### Reference
[一致性及解决一致性的两种方式：2PC和3PC](https://www.cnblogs.com/zcjcsl/p/7989792.html)

## TCC两段补偿型
**T**ry, **C**onfirm, **C**ancel
+ Try: 预留业务资源/数据效验
+ Confirm: 确认执行业务操作
+ Cancel: 取消执行业务操作
  类似于2PC，本质是应用层的2PC
+ 补偿: 用 短的事务 + 补偿 来替换 长的大事务

### 角色
+ 主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。
+ 从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作（Try）、确认操作（Confirm）、取消操作（Cancel）三个接口，供主业务服务调用。
+ 业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。

### 流程
+ 主业务服务首先开启本地事务；
+ 主业务服务向业务活动管理器申请启动分布式事务主业务活动；
+ 然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 Try 接口；
+ 当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务；
+ 若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口；
+ 所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。

### 缺点
+ 需要对每个分支定制相应的try, confirm和cancel接口
+ 且confirm和cancel接口需要做到幂等
+ try阶段超时，全部回滚，可能出现空回滚，某个RM没有收到请求，但是执行cancel，不会出现问题
+ 可能由于网络问题，出现先cancel，再try的情况，要保证该情况下，不能执行try

### Reference
[分布式事务之TCC服务设计和实现注意事项！](https://blog.csdn.net/bntx2jsqfehy7/article/details/81058746)

## 最大努力通知型

最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知等。最大努力通知型的实现方案，一般符合以下特点：

+ 不可靠消息：业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。
+ 定期校对：业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。

### 角色
+ 业务活动主动方：分布式事务发起方，本身包含RM，支持本地事务
+ 业务活动的被动方：分布式事务的参与者，本身包含RM，支持本地事务，通过消息机制接受事务请求，并且支持幂等、防重、查询等机制
+ 消息队列中间件：业务活动主动方在本地执行事务后，通过消息中间件通知事务其他参与方执行事务

### 流程
+ 业务活动主动方，执行本地事务
+ 业务活动主动方发送消息，如果消息发送失败，尝试N次
	+ 消息发送失败，不回滚本地事务
+ 消息发送成功，消息写入消息中间件
+ 消息中间件将消息发给消费方(业务活动的被动方)
+ 业务活动的被动方，收到消息后，处理分布式事务
	+ 处理失败，不断重试，有重试上限
	+ 处理成功，分布式事务成功，数据一致
+ 业务活动的被动方 定时通过 业务活动主动方接口查询未同步的数据
	+ 发现没有一致的，进行处理
	+ 为什么不是 被动方 提供接口，主动方去查询？
		+ 是因为主动方不能显示的知道有哪些被动参与方么，多个参与方的情况下，这样子会容易些

### Reference
[分布式事务解决方案(四)【最大努力通知】](https://blog.csdn.net/wulex/article/details/80938753)

## 消息补偿的最终一致
与**最大努力通知型**的差异在于，本类型，不允许消息失败。需要先开启事务消息，而**最大努力通知型**不需要。

### 角色
+ 业务活动主动方：分布式事务发起方，本身包含RM，支持本地事务
+ 业务活动的被动方：分布式事务的参与者，本身包含RM，支持本地事务，通过消息机制接受事务请求，并且支持幂等、防重、查询等机制
+ 消息队列中间件：业务活动主动方在本地执行事务后，通过消息中间件通知事务其他参与方执行事务

### 流程
+ 业务方执行事务，发送消息
	+ 向消息中心申请事务消息编号
	+ 消息中心相应，记录信息和状态(未发送)
	+ 业务方执行事务具体内容
		+ 执行失败，通知消息中心，该消息应该被丢弃
		+ 执行成功，通知消息中心，该消息允许被消费
		+ 消息中心如果超时未收到状态变更
			+ 根据业务方提供的接口（根据申请到的消息编号），查询状态
			+ 根据事务对应状态，处理对应消息
+ 消息中心将对应消息推送给消费方(另外一个事务参与者)
+ 消费方根据消息，执行相应的本地事务，以达成分布式事务	
	+ 消费方消费失败或者超时，消息中心会不断推送，直到超过限制
	+ 相应的接口需要做到幂等，和防重

### 分析
+ 性能好，只锁定本地事务
+ 侵入式代码，需要提供对应的check和处理逻辑
+ 会有数据不一致

### Reference
[分布式事务之异步消息补偿](https://blog.csdn.net/weixin_37672169/article/details/81254979)






